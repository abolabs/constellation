# You can override the included template(s) by including variable overrides
# SAST customization: https://docs.gitlab.com/ee/user/application_security/sast/#customizing-the-sast-settings
# Secret Detection customization: https://docs.gitlab.com/ee/user/application_security/secret_detection/#customizing-settings
# Dependency Scanning customization: https://docs.gitlab.com/ee/user/application_security/dependency_scanning/#customizing-the-dependency-scanning-settings
# Note that environment variables can be set in several places
# See https://docs.gitlab.com/ee/ci/variables/#cicd-variable-precedence
include:
- template: Security/Secret-Detection.gitlab-ci.yml
- template: Security/License-Scanning.gitlab-ci.yml
- template: Security/Dependency-Scanning.gitlab-ci.yml

variables:
  SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"  # Defines the location of the analysis task cache
  GIT_DEPTH: "0"  # Tells git to fetch all the branches of the project, required by the analysis task
  MARIADB_ROOT_PASSWORD: root
  MARIADB_DATABASE: Constellation
  MARIADB_USER: homestead
  MARIADB_PASSWORD: secret
  DB_HOST: mariadb
  REDIS_HOST: redis
  Host: redis
  REDIS_PORT: 6379
  SECRET_DETECTION_EXCLUDED_PATHS: vendor/**,node_modules/**

cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
  - vendor/
  - node_modules/
  - .env
  - composer.lock
  - package-lock.json
  - bootstrap/
  - .sonar/cache

stages:
  - test
  - scan
  - build
  - push

.base:
  image: registry.gitlab.com/abolabs/constellation/fpm:ci
  services:
  - mariadb:10.5
  - redis:3.0.6

.script-docker-registry-login: &script-docker-registry-login
  # docker login asks for the password to be passed through stdin for security
  # we use $CI_REGISTRY_PASSWORD here which is a special variable provided by GitLab
  # https://docs.gitlab.com/ce/ci/variables/predefined_variables.html
  - echo -n $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY


.script-prepare: &script-prepare
  # Copy over testing configuration.
  # Don't forget to set the database config in .env.testing correctly
  - cp .env.testing .env

  # Install Composer and project dependencies.
  - composer install

  # Generate an application key. Re-cache.
  - php artisan cache:clear
  - php artisan config:clear
  - php artisan key:generate
  - php artisan config:cache
  - php artisan route:cache

  # Install Node dependencies.
  # comment this out if you don't have a node dependency
  - npm install

  # Run npm build
  # comment this out if you don't have a frontend build
  # you can change this to to your frontend building script like
  # npm run build
  - npm run development

phpunit:
  stage: test
  extends: .base
  script:
  - *script-prepare
  - mysql --user=root --password="$MARIADB_ROOT_PASSWORD" --host=mariadb "$MARIADB_DATABASE" -e "grant all on *.* to '$MARIADB_USER'@'%' IDENTIFIED BY '$MARIADB_PASSWORD';flush privileges;"
  # Run database migrations.
  - php artisan migrate --force
  # Run database seed
  - php artisan db:seed --force

  # run laravel tests
  - mkdir -p reports/
  - XDEBUG_MODE=coverage ./vendor/bin/phpunit  --coverage-text --colors=never --coverage-clover reports/coverage.xml --log-junit reports/logfile.xml
  artifacts:
    name: "$CI_COMMIT_REF_SLUG"
    untracked: true
    expire_in: 1 day
    reports:
      junit: reports/logfile.xml
    paths:
      - reports/

sonarcloud-check:
  stage: scan
  image:
    name: sonarsource/sonar-scanner-cli:latest
    entrypoint: [""]
  dependencies:
  - "phpunit"
  script:
    - sonar-scanner
  only:
    - merge_requests
    - master
    - develop

build_fpm:
  stage: build
  image: docker:20
  services:
    - docker:20-dind
  script:
    - *script-docker-registry-login
    # fetches the latest image (not failing if image is not found)
    - docker pull $CI_REGISTRY_IMAGE/fpm:latest || true
    # builds the project, using OCI labels
    # notice the cache-from, which is going to use the image we just pulled locally
    # the built image is tagged locally with the commit SHA, and then pushed to
    # the GitLab registry
    - >
      docker build
      --pull
      --cache-from $CI_REGISTRY_IMAGE/fpm:latest
      --label "org.opencontainers.image.title=$CI_PROJECT_TITLE"
      --label "org.opencontainers.image.url=$CI_PROJECT_URL"
      --label "org.opencontainers.image.created=$CI_JOB_STARTED_AT"
      --label "org.opencontainers.image.revision=$CI_COMMIT_SHA"
      --label "org.opencontainers.image.version=$CI_COMMIT_REF_NAME"
      --tag $CI_REGISTRY_IMAGE/fpm:$CI_COMMIT_SHA
      --build-arg GIT_BRANCH="${CI_COMMIT_REF_NAME}"
      --build-arg MYUSER="constellation_user"
      --build-arg TAG_NAME="${CI_COMMIT_SHA}"
      --target=constellation-build
      ./install/prod/fpm
    - docker push $CI_REGISTRY_IMAGE/fpm:$CI_COMMIT_SHA
  only:
    - merge_requests
    - master
    - develop

build_nginx:
  stage: build
  image: docker:20
  services:
    - docker:20-dind
  needs:
    - build_fpm
  script:
    - *script-docker-registry-login
    # fetches the latest image (not failing if image is not found)
    - docker pull $CI_REGISTRY_IMAGE/nginx:latest || true
    # builds the project, using OCI labels
    # notice the cache-from, which is going to use the image we just pulled locally
    # the built image is tagged locally with the commit SHA, and then pushed to
    # the GitLab registry
    - >
      docker build
      --pull
      --cache-from $CI_REGISTRY_IMAGE/nginx:latest
      --label "org.opencontainers.image.title=$CI_PROJECT_TITLE"
      --label "org.opencontainers.image.url=$CI_PROJECT_URL"
      --label "org.opencontainers.image.created=$CI_JOB_STARTED_AT"
      --label "org.opencontainers.image.revision=$CI_COMMIT_SHA"
      --label "org.opencontainers.image.version=$CI_COMMIT_REF_NAME"
      --tag $CI_REGISTRY_IMAGE/nginx:$CI_COMMIT_SHA
      --build-arg GIT_BRANCH="${CI_COMMIT_REF_NAME}"
      --build-arg MYUSER="constellation_user"
      --build-arg TAG_NAME="${CI_COMMIT_SHA}"
      ./install/prod/nginx
    - docker push $CI_REGISTRY_IMAGE/nginx:$CI_COMMIT_SHA
  only:
    - merge_requests
    - master
    - develop

# Here, the goal is to tag the "master" branch as "latest"
push_latest:
  variables:
    # We are just playing with Docker here.
    # We do not need GitLab to clone the source code.
    GIT_STRATEGY: none
  stage: push
  image: docker:20
  services:
    - docker:20-dind
  script:
    - *script-docker-registry-login
    # Because we have no guarantee that this job will be picked up by the same runner
    # that built the image in the previous step, we pull it again locally
    - docker pull $CI_REGISTRY_IMAGE/fpm:$CI_COMMIT_SHA
    - docker pull $CI_REGISTRY_IMAGE/nginx:$CI_COMMIT_SHA
    # Then we tag it "latest"
    - docker tag $CI_REGISTRY_IMAGE/fpm:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE/fpm:latest
    - docker tag $CI_REGISTRY_IMAGE/nginx:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE/nginx:latest
    # Annnd we push it.
    - docker push $CI_REGISTRY_IMAGE/fpm:latest
    - docker push $CI_REGISTRY_IMAGE/nginx:latest
  only:
    # Only "master" should be tagged "latest"
    - master

# Finally, the goal here is to Docker tag any Git tag
# GitLab will start a new pipeline everytime a Git tag is created, which is pretty awesome
push_tag:
  variables:
    # Again, we do not need the source code here. Just playing with Docker.
    GIT_STRATEGY: none
  stage: push
  image: docker:20
  services:
    - docker:20-dind
  only:
    # We want this job to be run on tags only.
    - tags
  script:
    - *script-docker-registry-login
    - docker pull $CI_REGISTRY_IMAGE/fpm:$CI_COMMIT_SHA
    - docker tag $CI_REGISTRY_IMAGE/fpm:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE/fpm:$CI_BUILD_REF_SLUG
    - docker push $CI_REGISTRY_IMAGE/fpm:$CI_BUILD_REF_SLUG
    - docker pull $CI_REGISTRY_IMAGE/nginx:$CI_COMMIT_SHA
    - docker tag $CI_REGISTRY_IMAGE/nginx:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE/nginx:$CI_BUILD_REF_SLUG
    - docker push $CI_REGISTRY_IMAGE/nginx:$CI_BUILD_REF_SLUG
